# JVM垃圾收集器

## CMS 垃圾收集器
> Concurrent Mark Sweep (并发标记清除)
### 枚举根节点
当执行系统停顿下来后，并不需要一个不漏检查所有执行上下文和全局的引用位置，虚拟机应当时有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为 `OopMap`的数据结构来达到这个目的

### 安全点
在 `OopMap` 的帮助下，HotSpot可以快速且准确地完成GCRoots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说`OopMap`内容变化的指令非常多，如果为每一条指令都生成对应的 `OopMap`，那将会需要大量的额外空间，这样GC的空间成本将会变得非常高

实际上，HotSpot并没有为每条指令都生成 `OopMap`，而只是在 “特定的位置” 记录了这些信息，这些位置称之为安全点（`SafePoint`），即程序执行时并非在所有地方都能停顿下来开始GC，只有在达到安全点时才能暂停

`SafePoint`的选定既不能太少以至于让GC等待时间太长，也不能过于频繁以至于过分增大运行时的负载。所以，安全点的选定基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的--因为每条指令的执行时间非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间执行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生`SafePoint`

对于 `SafePoint`，另一个需要考虑的问题时如何在GC发生时让所有线程（这里不包括执行JNI调用的线程） 都“跑” 到最近的安全点上再停顿下来：抢占式中断（`Preemptive Suspension`）和主动式终端（`Voluntary Suspension`）
- 抢占式中断：它不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果有线程中断的地方不在安全点上，就恢复线程，让“它”跑到安全点上
- 主动式终端：当GC需要中断线程的时候，不直接对线程操作，仅仅简单设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志位真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外在加上创建对象需要分配内存的地方
- 现在几乎没有虚拟机采用抢占式中断来暂停线程从而响应GC事件

### 安全区域
在使用 `SafePoint` 似乎已经完美解决了如何进入GC的问题，但实际情况确不一定。SafePoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的 `SafePoint`。但是如果程序在“不执行”的时候呢？所谓程序不执行就是没有分配CPU时间，典型的例子就是出于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，JVM显然也不太可能登台线程重新分配CPU时间。对于这种情况，就需要**安全区域（Safe Regin）** 来解决了

在线程执行到 `Safe Regin` 中的代码时，首先标识自己已经进入了 `Safe Regin`，那样，当这段时间里JVM要发起GC时，就不用管标识自己为 `Safe Regin` 状态的线程了。在线程要离开 `Safe Regin` 时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开 `Safe Regin` 的信号为止

## CMS 垃圾收集器 深入理解

### CMS 垃圾收集器  理解

CMS（Concurrent Mark Sweep）收集器，以获取最短回收停顿时间为目标，多数应用于互联网或者B/S系统的服务器端上

CMS是基于“标记-清除”算法实现的，整个过程分为4个步骤
- 初始标记 （CMS initial mark）
- 并发标记  (CMS concurrent mark)
- 重新标记  (CMS remark)
- 并发清除  (CMS concurrent sweep)

其中初始标记和重新标记这两个步骤仍然需要“Stop The World”

初始标记 只是标记一下 `GC Roots` 能直接关联到的对象，速度很快

并发标记阶段就是进行 `GC Roots Tracing` 的过程，找到所有有引用的标记

重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短
- 相当于对并发标记那一步的标记的修正

CMS运作步骤如下图所示，在整个过程中耗时最长的额并发标记和并发清楚过程收集器线程都可以与用户线程一起工作，因此从总体上看，CMS收集器的内存回收过程始于用户线程一起并发执行的

![CMS垃圾收集器回收过程](../img/gc/CMS垃圾收集器回收过程.jpg)
- 初始标记 `Stop The World`
- 并发标记，和业务线程并行
- 重新标记 `Stop The World`
- 并发清除， 和业务线程并行

### CMS 垃圾收集器  优点

并发收集，低停顿，Oracle公司的一些官方文档中也称之为并发低停顿收集器 （Concurrent Low Pause Collection）

### CMS 垃圾收集器  缺点

CMS收集器对CPU资源非常敏感

CMS收集器无法处理浮动垃圾 （Floating Garbage）,可能出现 “Concurrent Mode Failure”失败而导致另一次Full GC的产生。如果在应用中老年代增长不是太快，可以适当调高参数 `-XX:CMSInitiatingOccupancyFraction`的值来提高出发百分比，以便降低内存回收次数从而获取更好的性能。要是CMS运行期间预留的内存无法满足程序需要时，虚拟机将启动后备预案：临时启用`Serial Old`收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数`-XX:CMSInitiatingOccupancyFraction` 设置太高很容易导致“Concurrent Mode Failure”失败，性能反而降低

收集结束会有大量空间随便产生，空间碎片过多的时候，将会给大对象分配带来很大麻烦，往往出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前进行一次Full GC。CMS收集器提供了一个 `-XX:+UseCMSCompactAtFullConllection` 开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不长
- 复制算法与标记清除算法对比可以理解成用空间换时间

### 空间分配担保

在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那么Minor GC可以确保是安全的。当大量对象在Minor GC后任然存活，就需要老年代进行空间分配担保，把Survivor无法容纳的对象直接进入老年代。如果老年代判断到剩余空间不足（根据以往每一次回收晋升到老年代对象容量的平均值作为经验值），则进行一次Full GC

### CMS 收集器收集步骤

- **Phase 1:** `Initial Mark`
- **Phase 2:** `Concurrent Mark`
- **Phase 3:** `Concurrent Preclean`
- **Phase 4:** `Concurrent Abortable Preclean`
    - 可能失败的
- **Phase 5:** `Final Remark`
- **Phase 6:** `Concurrent Sweep`
- **Phase 7:** `Concurrent Reset`

#### Phase 1 `Initial Mark`

这个是CMS两次 `Stop The World` 事件中的其中一次，这个阶段的目标是：标记哪些直接被`GC Root`引用或者被年轻代存活对象所引用的所有对象

![CMS_1_InitialMark](../img/gc/CMS_1_InitialMark.jpg)
- 标记 被 `GC Root` 引用
- 标记 被年轻代存活对象引用
- PS： CMS收集器是在老年代上使用的


#### Phase 2: `Concurrent Mark`

在这个阶段 Garbage Collector 会遍历老年代，然后标记所有存活的对象，它会根据上个阶段找到 `GC Roots` 遍历查找。并发标记阶段，它会与用户的应用程序并发运行。并不是老年代所有的存回对象都会被标记，因为在标记期间的用户程序可能会改变一些引用

![CMS_2_ConcurrentMark](../img/gc/CMS_2_ConcurrentMark.jpg)
- 在上面的图中，与阶段1的图进行对比，就会发现有一个对象的引用已经发生了变化

#### Phase 3: `Concurrent Preclean`

这也是一个并发阶段，与应用的线程并发运行，并不会stop应用的线程。在并发运行过程中，一些对象的引用可能会发生变化，但是这种情况发生时，JVM会将包含这个对象的区域（Card）标记为Dirty，也就是Card Marking

在pre-clean阶段，那些能够从Dirty对象到达的对象也会被标记，这个标记做完之后，dirty card标记就会被清除了

![CMS_3_ConcurrentPreClean](../img/gc/CMS_3_ConcurrentPreClean.jpg)


#### Phase 4: `Concurrent Abortable Preclean`

这也是一个并发阶段，但是同样不会影响用的应用线程，这个阶段是为了尽量承担STW（`Stop The World`）中最终标记阶段的工作。这个阶段持续时间依赖于很多的因素，由于这个阶段是在重复做很多相同的工作，直接满足一些条件（比如：重复迭代的次数、完成的工作量或者时钟时间等）

#### Phase 5: `Final Remark`

这个是第二个STW阶段，也是CMS中的最后一个，这个阶段的目标是标记老年代所有的存活对象，由于之前的阶段是并发执行的，gc线程可能更不上应用程序的变化，为了完成标记老年代所有存活对象的目标，STW就非常有必要了

通常CMS的Final Remark阶段会在年轻代尽可能干净的时候运行，目的是为了减少连续STW发生的可能性（年轻代存活对象过多的话，也会导致老年代涉及的存活对象会很多）。这个阶段会比前面的几个阶段更复杂一些

---

标记阶段结束

---

#### Phase 6: `Concurrent Sweep`

这里不需要STW，它是与用户的应用程序并发运行，这个阶段是：清除那些不在使用的对象，回收它们的占用空间为将来使用

![CMS_6_ConcurrentSweep](../img/gc/CMS_6_ConcurrentSweep.jpg)

#### Phase 7: `Concurrent Reset`

这个阶段也是并发执行的，它会重设CMS内部的数据结构，为下次的GC做准备


---

## G1 垃圾收集器 `Garbage First Collector`

### G1 出现的契机

- 吞吐量
- 响应能力

#### 吞吐量

吞吐量关注的是，在一个指定的时间内，最大化一个应用的工作量。

如下方式来衡量一个系统吞吐量的好坏：
    - 在一小时内同一事务（或者任务、请求）完成的次数（tps）
    - 数据库一小时可以完成多少次查询

对于关注吞吐量的系统，卡顿是可以接受的，因为这个系统关注长时间的大量任务的执行能力，单次快速的响应并不值得考虑。

#### 响应能力

响应能力是指一个程序或者系统对请求是否能够及时响应，比如：
- 一个桌面UI能多块地相应一个事件
- 一个网站能够多块返回一个页面请求
- 数据库能够多块返回查询的数据

对于这类对响应能力敏感的场景，长时间的停顿是无法接受的

### G1 Garbage Collector 特点

G1收集器是一个面向服务端的垃圾收集器，适用于多核处理器、大内存容量的服务端系统

它满足短时间gc停顿的同时达到一个较高的吞吐量

JDK7以上版本适用

### G1 设计目标

与应用线程同时工作，几乎不需要stop the world(与cms类似)

整理剩余空间，不产生内存碎片（CMS只能在Full GC时，用stop the world整理内存碎片）

GC停顿更加可控

不牺牲系统的吞吐量

GC不要求额外的内存空间（CMS需要预留空间存储**浮动垃圾**）
- 浮动垃圾：CMS在并发清除的时候，用户线程更改了对象的引用
    - 用户线程认为这个是垃圾
    - GC线程还没有认为这个是垃圾

### G1的设计规划是要替换掉CMS

G1在某些方面弥补了CMS的不足，比如，CMS使用的是 `mark-sweep` 算法，自然会产生内存碎片；然而G1基于 `Copying`算法，高效的整理剩余内存，而不需要管理内存碎片

另外，G1提供了更多手段，以达到对gc停顿时间的可控


### Hotspot虚拟机的构成

![Hotspt虚拟机的构成](img/gc/Hotspt虚拟机的构成.jpg

### 传统垃圾收集器的堆结构

![传统垃圾收集器堆结构](../img/gc/传统垃圾收集器堆结构.jpg)

- 永久代在JDK8之后没有了 变成了原空间

### G1垃圾收集器堆结构

![G1垃圾收集器堆结构](../img/gc/G1垃圾收集器堆结构.jpg)
- 在G1中，整个堆空间是一个整体
- 不会划分出一块连续的区域作为新生代，老年代什么的
- 其中灰色的是没有被使用的

**堆结构**
- heap被划分成一个个相等的不连续的内存区域（regions），每个region都有一个分代角色
    - `eden`,`survivor`,`old`
- 对每个角色的数量并没有强制的限定，也就是说每种分代的内存大小，可以动态变化
    - 每个分代内存的大小可以动态变化
- G1最大的特点就是高效的执行回收，优先区执行哪些大量对象可回收的区域（region）
- G1使用了gc停顿可预测的模型，来满足用户设定的gc停顿时间，根据用户设定的目标时间，G1会自动地选择哪些region要清除，一个清除多少个region
- G1从多个region中复制存活的对象，然后集中放入到一个region中，同时整理、清楚捏村（copying收集算法）

### G1 vs CMS
- 对比使用mark-sweep的cms，G1使用的copying算法不会造成内存碎片
- 对比Parallel Scavenge（基于Copying）、Parallel Old收集器（基于 mark-compact-sweep）,Parallel 会对整个区域做整理导致gc停顿会比较长，而G1只是特定地整理几个 region
- G1并非一个实时的收集器，与Parallel Scavenge一样，对gc停顿时间的设置并不据对生效，只是G1有较高的几率保证不超过设定的gc停顿时间。与之前的gc收集器对比，G1会根据用户设定的gc停顿时间，智能评估哪几个region需要被回收可以满足用户的设定

### G1重要概念

- 分区（Region）
    - G1采取了不同的策略来解决并行、串行和CMS收集器的碎片、暂停时间不可控等问题
    - G1将**整个堆**分成**相同大小**的分区（Region）
        - 大小相同，角色不同
- 每个分区都可能是年轻代也可能是老年代，但是在同一时刻只能属于某个代。
    - 年轻代、幸存代、老年代这些概念还存在，成为逻辑上的概念
    - 这样方便复用之前分代框架的逻辑
- 在物理上不许哟啊连续，则带来的额外的好处
    - 有的分区内垃圾对象特别多，有的分区内垃圾对象很少
    - **G1会优先回收垃圾对象特别多的分区（Garbage First）**
        - 这样可以花费较少的时间来回收这些分区的垃圾
        - 这也是G1名字的由来，即首先收集垃圾最多的分区
- 依然实在新生代满了的时候，对整个新生代进行回收
    - 整个新生代的对象，要么被回收、要么晋升
    - 至于新生代也采取分区机制的原因
        - **则是因为这样跟老年代的策略统一，方便调整代的大小**
- G1还是一种带压缩的收集器，在回收老年代的分区时，是将存活的对象从一个分区拷贝到另一个可用分区
    - 这个拷贝过程就实现了局部的压缩
- **已记忆集合（RSet）**
    - RSet记录了其他Region中对象的关系，属于 points-into 结构（谁引用了我的对象）
    - RSet的价值在于是的垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可
    - 解释：Region1和Region3中的对象都引用了Region2中的对象，因此在Region2的RSet中记录了这两个引用
        ![RSet](../img/gc/RSet.jpg)

- G1 GC是在point-out的card table之上再加了一层结构来构成points-into RSet
    - 每个 region 会记录下到底哪些被的region有指向自己的指针，而这些指针分别在哪些card的范围内
    - 这个RSet其实是一个hash table
        - key是别的region的起始地址
        - value是一个集合，里面的元素是card table的index。
        > 举例来说，如果region A的RSet里有一项的key是region B，value里有index为1234的card，它的意思就是regionB的一个card里有引用指向region A。所以堆region A来说，该RSet记录的是points-into的关系；而card table仍然记录的points-out的关系
- `Snapshot-At-The-Beginning(SATB)`
    - SATB 是G1 GC在并发标记阶段使用的增量式的标记算法
    - 并发标记是并发多线程的，但并发线程在同一时刻只扫描一个分区


### G1垃圾收集器官方文档

[G1文档](https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html)

[G1文档 来自Oracle](G1_Document.md)




